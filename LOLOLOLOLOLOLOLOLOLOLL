-- External script (vortex.lua)

-- Fetch the hitbox size, FOV, and visual hitbox setting from the environment variables
local hitboxSize = getgenv().HitboxSize
local fov = getgenv().FOV  -- Fetch the FOV setting
local visualHitbox = getgenv().VisualHitbox  -- Fetch the visual hitbox toggle

-- Table to store visual hitboxes
local visualHitboxParts = {}

game:GetService("RunService").RenderStepped:Connect(function()
    local camera = game.Workspace.CurrentCamera  -- Get the current camera
    local cameraPosition = camera.CFrame.Position  -- Camera's position in the world
    local cameraForward = camera.CFrame.LookVector  -- Camera's forward direction vector

    -- Iterate through all players
    for _, player in next, game.Players:GetPlayers() do
        if player ~= game.Players.LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = player.Character.HumanoidRootPart
            local playerPosition = humanoidRootPart.Position  -- Get player's position
            local playerDirection = (playerPosition - cameraPosition).unit  -- Get direction from camera to player
            local dotProduct = cameraForward:Dot(playerDirection)  -- Dot product of camera direction and player direction

            -- Calculate the angle between camera and player
            local angle = math.deg(math.acos(dotProduct))  -- Convert the dot product to an angle

            -- Check if the player is within the specified FOV (ensure FOV logic is correct)
            if angle <= fov then
                -- Apply hitbox expansion if within the FOV
                humanoidRootPart.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                humanoidRootPart.CanCollide = false  -- Allow walking through the player

                -- Show visual hitbox if enabled
                if visualHitbox then
                    -- Create a visual hitbox part if not already created
                    if not visualHitboxParts[player.UserId] then
                        local visualPart = Instance.new("Part")
                        visualPart.Size = humanoidRootPart.Size
                        visualPart.Shape = Enum.PartType.Ball  -- You can use Ball or Block shape
                        visualPart.Position = humanoidRootPart.Position
                        visualPart.Anchored = true
                        visualPart.CanCollide = false
                        visualPart.Transparency = 0.5  -- Semi-transparent to see through it
                        visualPart.Color = Color3.fromRGB(255, 0, 0)  -- Red color
                        visualPart.Parent = player.Character

                        -- Store the visual part in the table for later reference
                        visualHitboxParts[player.UserId] = visualPart
                    else
                        -- Update existing visual hitbox part size and position
                        local visualPart = visualHitboxParts[player.UserId]
                        visualPart.Size = humanoidRootPart.Size
                        visualPart.Position = humanoidRootPart.Position
                    end
                end
            else
                -- Reset hitbox size if outside the FOV
                humanoidRootPart.Size = humanoidRootPart.Size  -- Keep original size
                humanoidRootPart.CanCollide = true  -- Re-enable collision

                -- Remove the visual hitbox if outside the FOV and visual hitbox is enabled
                if visualHitbox and visualHitboxParts[player.UserId] then
                    visualHitboxParts[player.UserId]:Destroy()  -- Remove visual part
                    visualHitboxParts[player.UserId] = nil  -- Clear reference
                end
            end
        else
            -- If the player doesn't have a humanoidRootPart, remove their visual hitbox if it exists
            if visualHitboxParts[player.UserId] then
                visualHitboxParts[player.UserId]:Destroy()
                visualHitboxParts[player.UserId] = nil
            end
        end
    end
end)
